# algorithms
golang algorithms
### Асимптотическая сложность
* Асимптотическая сложность (производительность) определяется функцией, которая указывает, насколько ухудшается работа алгоритма с усложнением поставленной задачи. Такую функцию записывают в круглых скобках, предваряя прописной буквой О.
* Существуют пять основных правил для расчета асимптотической сложности алгоритма.
    1. Если для математической функции  f алгоритму необходимо выполнить определенные действия f(N) раз, то для этого ему понадобится сделать O(f(N)) шагов.
    2. Если алгоритм выполняет одну операцию, состоящую из O(f(N)) шагов, а затем вторую операцию, включающую O(g(N)) шагов, то общая производительность алгоритма для функций f и g составит O(f(N) + g(N)).
    3. Если алгоритму необходимо сделать O(f(N)+g(N)) шагов и область значений N функции f(N) больше, чем у g(N), то асимптотическую сложность можно упростить до выражения O(f(N)).
    4. Если алгоритму внутри каждого шага O(f(N)) одной операции приходится выполнять еще O(g(N)) шагов другой операции, то общая производительность алгоритма составит O(f(N) u g(N)).
    5. Постоянными множителями(константами)можно пренебречь.Если C является константой, то O(C u f(N)) или O(f(C u N)) можно записать как O(f(N)).

* Правило 1
  Если для математической функции f алгоритму необходимо выполнить определенные действия f(N) раз, то для этого ему понадобится сделать O(f(N)) шагов.
    + Рассмотрим псевдокод с алгоритмом по нахождению наибольшего целого числа в массиве.
        ```
          Integer: FindLargest(Integer: array[])
           Integer: largest = array[0]
           For i = 1 To <наибольший индекс>
                   If (array[i] > largest) Then largest = array[i]
           Next i
            Return largest
        End FindLargest
        ```
    + В качестве входного параметра алгоритм FindLargest использует массив целых чисел, результат возвращается в виде одного целого числа. В самом начале переменной largest присваивается значение первого элемента массива. Затем алгоритм перебирает оставшиеся элементы и сравнивает значение каждого из них с largest. Если он находит большую величину, то приравнивает largest к ней и по окончании цикла возвращает наибольшее найденное значение.
      Алгоритм проверяет каждый из N элементов массива всего один раз, поэтому его производительность составляет O(N).

* Правило 2
    + Если алгоритм выполняет одну операцию, состоящую из O(f(N)) шагов, а затем вторую, требующую O(g(N)) шагов, то общая производительность алгоритма для функций f и g будет O(f(N) + g(N)).
    + Вернемся к алгоритму FindLargest. На этот раз обратите внимание, что несколько строк в действительности не включены в цикл. В следующем псевдокоде в комментариях справа приведен порядок времени выполнения все тех же шагов.
        ```
        Integer: FindLargest(Integer: array[])
           Integer: largest = array[0]            // O(1)
           For i = 1 To <наибльший индекс>        // O(N)
                   If (array[i] > largest) Then largest = array[i]
           Next i
           Return largest                         // O(1)
        End FindLargest
        ```
    + Итак, приведённый алгоритм выполняет один шаг отладки перед циклом и еще один после него. Каждый из них имеет производительность O(1) (это однократное действие), поэтому общее время работы алгоритма составит O(1 + N + 1). Если использовать обычную алгебру и преобразовать выражение, то получится O(2 + N).

* Правило 3
    + Если алгоритму необходимо сделать O(f(N) + g(N)) шагов и область значений N функции f(N) больше, чем у g(N), то асимптотическую сложность можно упростить до выражения O(f(N)).
    + В предыдущем примере мы выяснили, что время работы алгоритма FindLargest определяется выражением O(2 + N). Если параметр N начнет возрастать, его значение превысит постоянную величину 2 и предыдущее выражение можно будет упростить до O(N).
    + Игнорирование меньших функций позволяет пренебречь небольшими задачами отладки и очистки, чтобы сосредоточить внимание на асимптотическом поведении алгоритма, которое обнаруживается при усложнении задачи. Другими словами, время, затраченное алгоритмом на построение простых структур данных перед выполнением объемного вычисления, является несущественным по сравнению с длительностью основных расчетов.
* Правило 4
    + Если алгоритму внутри каждого шага O(f(N)) одной операции приходится выполнять еще O(g(N)) шагов другой операции, то общая производительность алгоритма составит O(f(N) u g(N)).
    + Рассмотрим алгоритм, который определяет, содержатся ли в массиве повторяющиеся элементы. (Стоит отметить, что это не самый эффективный способ обнаружения дубликатов.)
        ```
        Boolean: ContainsDuplicates(Integer: array[])
           // Цикл по всем элементам массива.
           For i = 0 To <наибольший индекс>
              For j = 0 To <наибольший индекс>
              // Проверяем, являются ли два элемента дубликатами. If (i != j) Then
                  If (i != j) Then
                      If (array[i] == array[j]) Then Return True
                  End If
              Next j
           Next i
          // Если мы дошли до этой строки, то дубликатов нет.
          Return False
      End ContainsDuplicates
      ```
    + Алгоритм содержит два цикла, один из которых является вложенным. Внешний цикл перебирает все элементы массива N, выполняя O(N) шагов. Внутри каждого такого шага внутренний цикл повторно пересматривает все N элементов массива, совершая те же O(N) шагов. Следовательно, общая производительность алгоритма составит O(N u N) = O(N2).
* Правило 5
    + Постоянными множителями (константами) можно пренебречь. Если C является константой, то O(C u f(N)) или O(f(C u N)) можно записать как O(f(N)).
    + Снова посмотрите на алгоритм ContainsDuplicates из предыдущего примера и обратите внимание на внутренний цикл, который представлен условием If. В рамках этого условия определяется, равны ли друг другу индексы i и j. Если нет — тогда сравниваются величины array[i] и array[j], в случае их совпадения возвращается значение True.
    + Пренебрегая дополнительным шагом в выражении Return (как правило, он выполняется один раз), предположим, что срабатывают оба оператора If (а так и происходит в большинстве случаев), тогда внутренний цикл будет пройден за O(2N) шагов. Следовательно, общая производительность алгоритма составит O(N u 2N) = = O(2N2). Последнее правило позволяет пренебречь коэффициентом 2 и записать производительность алгоритма в виде O(N2).
    + На самом деле мы возвращаемся к сути асимптотической сложности: нужно выяснить, как поведет себя алгоритм, если N начнет возрастать. Предположим, вы увеличите N в два раза, то есть будете оперировать значением 2N. Теперь если подставить фразу в выражение 2N2, получится следующее: 2 u (2N)2 = 2 u 4N2 = 8N2. Это и есть наша величина 2N2, только умноженная на 4. Таким образом, время работы алгоритма увеличится в четыре раза.
    + Теперь давайте оценим производительность алгоритма, используя упрощенное по правилу выражение O(N2). При подстановке в него 2N получим следующее: (2N)2 = 4N2. То есть наша изначальная величина N2 возросла в четыре раза, как и время работы алгоритма.
    + Из всего вышесказанного следует, что независимо от того, будете вы использовать развернутую формулу 2N2 или ограничитесь просто N2, результат останется прежним: увеличение сложности задачи в два раза замедлит работу алгоритма в четыре раза. Таким образом, важной здесь является не константа 2,а тот факт, что время работы увеличивается вместе с увеличением количества вводов N2.
    + ЗАМЕЧАНИЕ
        + Важно помнить, что асимптотическая сложность дает представление о теоретическом поведении алгоритма. Практические результаты могут отличаться. Предположим, производительность алгоритма равна O(N); если не пренебрегать целыми числами, реальное количество выполняемых шагов составит приблизительно 100 000 000 + N. В этом случае, пока N не слишком велико, значение константы лучше учитывать.


### O(1)
    Константное время нахождение результата
### Log (N)
    Алгоритм с производительностью O(log (N)) делит количество рассматриваемых им элементов на фиксированный коэффициент при каждом шаге.
### sqrt (N)
    Алгоритмы с производительностью O(sqrt (N)), где sqrt — функция извлечения квадратного корня, не являются общими и не рассматриваются в данной книге.
    Эта функция возрастает очень медленно, хотя и несколько быстрее, чем log (N).
### N
    Алгоритм FindLargest (см. пункт «Правило 1» подраздела «Асимптотическая сложность алгоритма» в разделе «Свойство алгоритма» текущей главы) имеет производительность O(N).
    Функция N возрастает быстрее, чем log (N) и sqrt (N), но все же не так быстро, поэтому большинство подобных алгоритмов демонстрирует на практике хорошую производительность.
### N log N
    Предположим, что алгоритм перебирает все элементы в поставленной задаче, а затем в отдельном цикле выполняет с элементом какую-то операцию O(log (N)).
    В этом случае производительность алгоритма определяется выражением O(N u log N) или O(N log N).
    Как вариант, задача может выглядеть так: алгоритм выполняет операцию O(log (N)) и на каждом ее шаге что-то делает с каждым элементом.
    Предположим, у вас есть отсортированное дерево, содержащее N элементов (как описано выше) и такой же размерности массив.
    Вам надо узнать, какие из элементов массива присутствуют в дереве.
    Один из способов выяснить это — осуществить циклическое прохождение по величинам массива, задействовав описанный ранее метод поиска по дереву.
    В процессе работы алгоритм проверит N элементов и выполнит log (N) шагов для каждого из них, так что общая производительность будет O(N u log N).
    Для многих алгоритмов сортировки, основанных на сравнении элементов, время работы составляет O(N u log N).
    На самом деле можно доказать, что любой подобный алгоритм проходит как минимум такое количество шагов, что очень удобно для определения асимптотической сложности.
    Однако некоторые алгоритмы являются все же более быстрыми благодаря целым числам, которые игнорируются асимптотическим обозначением.
### N2
    Алгоритм, который изначально перебирает все входные данные, а затем пересматривает их еще раз для каждого единичного значения, имеет производительность O(N2).
    Например, алгоритм ContainsDuplicates (см. пункт «Правило 4» подраздела «Асимптотическая сложность алгоритма» в разделе «Свойство алгоритма» текущей главы) выполняется именно за такое время.
    Возможны и другие степени N, предположим O(N3) или O(N4). Однако они являются значительно более медленными, чем O(N2).
    Говорят, алгоритм имеет многочленное время работы, если оно включает в себя многочлен N: например O(N), O(N2), O(N6) и даже O(N4000).
    В любом случае подобные задачи можно решить. А вот экспоненциальное и факториальное время работы, описанное ниже, возрастает очень быстро, поэтому алгоритмы с указанной производительностью будут применимы только для небольшого количества входных данных.
### 2N
    Экспоненциальные функции, такие как 2N, возрастают молниеносно и поэтому полезны для решения ограниченного круга задач.
    Обычно посредством алгоритмов с подобным временем работы ищется оптимальный набор входных данных.
    В качестве примера рассмотрим следующую задачу. Допустим, у вас есть рюкзак определенной грузоподъемности и набор принадлежностей, каждый из которых имеет свою массу и значение.
    Вам необходимо наполнить рюкзак предметами так, чтобы их общее значение оказалось наибольшим.
    Задача может показаться простой, но все известные алгоритмы для нахождения наилучшего решения потребуют изучить каждую возможную комбинацию предметов.
    Если учесть, что любой предмет способен пребывать только в двух состояниях (находиться в рюкзаке или вне его), то, умножив количество состояний на количество предметов, получим 2 u 2 u ... u 2 = 2N вариантов выбора.
    Иногда нет необходимости проверять все возможные комбинации. Например, если первый предмет заполняет собой рюкзак, то добавлять к нему еще что-то уже не имеет смысла. Однако в большинстве случаев вам не удастся исключить доста- точное количество вариантов, чтобы значительно сузить область поиска.
    При решении задач с экспоненциальным временем работы часто пользуются эвристиками — алгоритмами, которые дают хорошие результаты, но не гарантируют, что они будут наилучшими.
### N!
    Функция N! (читается как «N факториал») рекомендуется для работы с целыми числами больше 0 и определяется формулой N! = 1 u 2 u 3 u ... u N.
    Она возрастает намного быстрее, чем экспоненциальная функция 2N.
    В алгоритмах с факториальным временем работы, как правило, ищется оптимальное распределение входных данных.
    Например, у торгового представителя имеется список городов. Его задача — составить маршрут таким образом, чтобы посетить каждый населенный пункт один раз и вернуться в отправную точку, преодолев минимальное расстояние.
    Если городов немного, то все просто, но если список длинный, задача усложняется на порядок.
    Наиболее очевидный способ решения — перебрать все возможные варианты маршрута. Так, с помощью алгоритма можно выбрать N близлежащих населенных пунктов для первого города. После этого у вас останется N – 1 возможных пунктов, которые еще нужно посетить, затем N – 2 и т. д. Следовательно, общее количество вариантов маршрутов составит N u (N – 1) u u (N – 2) u ... u 1 = N!.
